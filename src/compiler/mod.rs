use std::io::Result;

use crate::generator::{Block, Codegen};
use crate::{NAME, VERSION};

use dbml_rs::ast::table::TableBlock;
use inflector::Inflector;

use self::config::*;
use self::traits::*;

use dbml_rs::*;

pub mod config;
pub mod err;
pub mod traits;
pub mod utils;

#[derive(Clone, Copy)]
enum EntityProfile {
  Normal,
  Create,
  Update,
}

pub fn compile(ast: analyzer::SemanticSchemaBlock, config: &Config) -> Result<String> {
  let codegen = Codegen::new().line(format!("//! Generated by {NAME} {VERSION}"));

  let codegen = gen_model_modules(&ast, codegen, config);
  let codegen = gen_enum_modules(&ast, codegen, config);

  Ok(codegen.to_string())
}

fn gen_model_modules(ast: &analyzer::SemanticSchemaBlock, codegen: Codegen, config: &Config) -> Codegen {
  ast.tables.clone().iter().fold(codegen, |acc, table| {
    let ident = &table.ident;

    let macros: Vec<_> = vec![format!("FromRow")]
      .into_iter()
      .chain(config.table_macros.clone())
      .collect();

    let mut mod_block = Block::new(1, Some(format!("pub mod {}", ident.name.to_snake_case())))
      .line("use sqlx::*;");

    if true {
      mod_block = gen_model_block_with_profile(
        table.clone(),
        mod_block,
        config,
        EntityProfile::Normal,
        macros.clone()
      );
    }
    if config.is_with_create_model {
      mod_block = gen_model_block_with_profile(
        table.clone(),
        mod_block,
        config,
        EntityProfile::Create,
        macros.clone()
      );
    }
    if config.is_with_update_model {
      mod_block = gen_model_block_with_profile(
        table.clone(),
        mod_block,
        config,
        EntityProfile::Update,
        macros.clone()
      );
    }

    acc.line_skip(1).block(mod_block)
  })
}

fn gen_model_block_with_profile(
  table: TableBlock,
  block: Block,
  config: &config::Config,
  profile: EntityProfile,
  macros: Vec<String>,
) -> Block {
  let table_block = gen_model_module_with_profile(
    table.clone(),
    config,
    profile,
  );

  let mut block = block
    .line_skip(1)
    .line(format!("#[derive({})]", macros.join(", ")))
    .block(table_block);
    
  if config.is_with_into_args_pair_method {
    let table_block = gen_model_into_args_pair_method(
      table.clone(),
      config,
      profile,
    );

    block = block
      .line_skip(1)
      .block(table_block);
  }

  block
}

fn gen_model_module_with_profile(
  table: TableBlock,
  config: &config::Config,
  profile: EntityProfile,
) -> Block {
  let ast::table::TableBlock {
    cols: fields,
    indexes,
    ..
  } = table;

  let table_block = match profile {
    EntityProfile::Normal => Block::new(2, Some(format!("pub struct {}", "Model"))),
    EntityProfile::Create => Block::new(2, Some(format!("pub struct {}", "CreateModel"))),
    EntityProfile::Update => Block::new(2, Some(format!("pub struct {}", "UpdateModel"))),
  };

  fields.iter().cloned().fold(table_block, |acc, field| {
    match profile {
      EntityProfile::Normal => (),
      EntityProfile::Create => {
        if field.settings.is_pk {
          match config.is_create_model_primary_key_included {
            None if field.settings.is_incremental => {
              return acc;
            }
            Some(false) => {
              return acc;
            }
            _ => (),
          }
        }
      }
      EntityProfile::Update => {
        if field.settings.is_pk && !config.is_update_model_primary_key_included {
          return acc;
        }
      }
    };

    let mut field_rust_type = field.r#type.to_rust_type();

    match profile {
      EntityProfile::Normal => {
        if field.settings.is_nullable {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      },
      EntityProfile::Create => {
        if field.settings.is_nullable || field.settings.default.is_some() {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      },
      EntityProfile::Update => {
        if !field.settings.is_pk {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      }
    };

    match &config.struct_visibility {
      StructVisibility::Public => {
        acc
          .line(format!("pub {}: {},", field.name, field_rust_type))
      },
      StructVisibility::Private => {
        acc
          .line(format!("{}: {},", field.name, field_rust_type))
      }
    }
  })
}

fn gen_model_into_args_pair_method(
  table: TableBlock,
  config: &config::Config,
  profile: EntityProfile,
) -> Block {
  let ast::table::TableBlock {
    cols: fields,
    indexes,
    ..
  } = table;

  let impl_block = match profile {
    EntityProfile::Normal => Block::new(2, Some(format!("impl {}", "Model"))),
    EntityProfile::Create => Block::new(2, Some(format!("impl {}", "CreateModel"))),
    EntityProfile::Update => Block::new(2, Some(format!("impl {}", "UpdateModel"))),
  };

  let before_method_block = format!("pub fn into_args_pair(self, only_pks: Option<bool>) -> (Vec<&'static str>, postgres::PgArguments)");
  let method_block = Block::new(3, Some(before_method_block))
    .line(format!("let mut f = Vec::with_capacity({});", fields.len()))
    .line(format!("let mut a = postgres::PgArguments::default();"));

  let before_if_pks_block = format!("if matches!(only_pks, None | Some(true))");
  let mut if_pks_block = Block::new(4, Some(before_if_pks_block));

  let before_if_pks_block = format!("if matches!(only_pks, None | Some(false))");
  let mut if_non_pks_block = Block::new(4, Some(before_if_pks_block));

  for field in fields.iter().cloned() {
    match profile {
      EntityProfile::Normal => {
        if field.settings.is_pk {
          if_pks_block = if_pks_block.line(format!(r#"(f.push("{}"), a.add(self.{}));"#, field.name, field.name));
        } else if field.settings.is_nullable {
          if_non_pks_block = if_non_pks_block.line(format!(r#"self.{}.map(|v| (f.push("{}"), a.add(v)));"#, field.name, field.name));
        } else {
          if_non_pks_block = if_non_pks_block.line(format!(r#"(f.push("{}"), a.add(self.{}));"#, field.name, field.name));
        }
      },
      EntityProfile::Create => {
        if field.settings.is_pk {
          match config.is_create_model_primary_key_included {
            None if field.settings.is_incremental => {
              continue;
            }
            Some(false) => {
              continue;
            }
            _ => (),
          }
        }

        if field.settings.is_pk {
          if_pks_block = if_pks_block.line(format!(r#"(f.push("{}"), a.add(self.{}));"#, field.name, field.name));
        } else if field.settings.is_nullable || field.settings.default.is_some() {
          if_non_pks_block = if_non_pks_block.line(format!(r#"self.{}.map(|v| (f.push("{}"), a.add(v)));"#, field.name, field.name));
        } else {
          if_non_pks_block = if_non_pks_block.line(format!(r#"(f.push("{}"), a.add(self.{}));"#, field.name, field.name));
        }
      }
      EntityProfile::Update => {
        if field.settings.is_pk && !config.is_update_model_primary_key_included {
          continue;
        }

        if field.settings.is_pk {
          if_pks_block = if_pks_block.line(format!(r#"(f.push("{}"), a.add(self.{}));"#, field.name, field.name));
        } else {
          if_non_pks_block = if_non_pks_block.line(format!(r#"self.{}.map(|v| (f.push("{}"), a.add(v)));"#, field.name, field.name));
        }
      }
    };
  }

  let method_block = method_block
    .block(if_pks_block)
    .block(if_non_pks_block)
    .line("(f, a)");

  impl_block
    .block(method_block)
}

fn gen_enum_modules(ast: &analyzer::SemanticSchemaBlock, codegen: Codegen, config: &Config) -> Codegen {  
  ast.enums.clone().into_iter().fold(codegen, |acc, r#enum| {
    let ast::enums::EnumBlock {
      ident: ast::enums::EnumIdent { name, schema },
      values,
    } = r#enum;

    let enum_block = Block::new(1, Some(format!("pub enum {}", name.to_pascal_case())));

    let enum_block = values.into_iter().enumerate().fold(enum_block, |acc, (i, value)| {
      let value_name = value.value;
      let value = match config.enum_type {
        EnumType::Integer => {
          format!("{} = {}", value_name.to_pascal_case(), i)
        },
        EnumType::String(_) => {
          format!("{}", value_name.to_pascal_case())
        }
      };

      acc
        .line(format!("{},", value))
    });

    let sqlx_macro = match &config.enum_type {
      EnumType::Integer => {
        format!("#[repr(i32)]")
      },
      EnumType::String(case) => {
        let case = case.as_ref().map(|case| {
          match case {
            EnumTypeCase::LowerCase => "lowercase",
            EnumTypeCase::SnakeCase => "snake_case",
            EnumTypeCase::UpperCase => "UPPERCASE",
            EnumTypeCase::ScreamingSnakeCase => "SCREAMING_SNAKE_CASE",
            EnumTypeCase::KebabCase => "kebab-case",
            EnumTypeCase::CamelCase => "camelCase",
            EnumTypeCase::PascalCase => "PascalCase",
          }
        });

        let mut attrs = vec![];

        attrs.push(format!(r#"type_name = "{}""#, name));

        if let Some(case) = case {
          attrs.push(format!(r#"rename_all = "{}""#, case));
        }

        format!(r#"#[sqlx({})]"#, attrs.join(", "))
      }
    };

    let marcros: Vec<_> = vec![format!("sqlx::Type")]
      .into_iter()
      .chain(config.enum_macros.clone())
      .collect();
    acc
      .line_skip(1)
      .line(format!("#[derive({})]", marcros.join(", ")))
      .line(format!("{}", sqlx_macro))
      .block(enum_block)
  })
}
