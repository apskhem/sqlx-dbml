use std::io::Result;

use crate::generator::{Block, Codegen};
use crate::{NAME, VERSION};

use dbml_rs::ast::table::TableBlock;
use inflector::Inflector;

use self::config::*;
use self::traits::*;

use dbml_rs::*;

pub mod config;
pub mod err;
pub mod traits;
pub mod utils;

enum EntityProfile {
  Normal,
  Create,
  Update,
}

pub fn compile(ast: analyzer::SemanticSchemaBlock, config: &Config) -> Result<String> {
  let codegen = Codegen::new().line(format!("//! Generated by {NAME} {VERSION}"));

  let codegen = gen_model_modules(&ast, codegen, config);
  let codegen = gen_enum_modules(&ast, codegen, config);

  Ok(codegen.to_string())
}

fn gen_model_modules(ast: &analyzer::SemanticSchemaBlock, codegen: Codegen, config: &Config) -> Codegen {
  ast.tables.clone().iter().fold(codegen, |acc, table| {
    let ident = &table.ident;

    let marcros: Vec<_> = vec![format!("FromRow")]
      .into_iter()
      .chain(config.table_macros.clone())
      .collect();

    let mut mod_block = Block::new(1, Some(format!("pub mod {}", ident.name.to_snake_case())))
      .line("use sqlx::*;");

    if true {
      let table_block = gen_model_module_with_profile(
        table.clone(),
        config,
        EntityProfile::Normal,
      );

      mod_block = mod_block
        .line_skip(1)
        .line(format!("#[derive({})]", marcros.join(", ")))
        .block(table_block);
    }
    if config.is_with_create_model {
      let table_block = gen_model_module_with_profile(
        table.clone(),
        config,
        EntityProfile::Create,
      );

      mod_block = mod_block
        .line_skip(1)
        .line(format!("#[derive({})]", marcros.join(", ")))
        .block(table_block);
    }
    if config.is_with_update_model {
      let table_block = gen_model_module_with_profile(
        table.clone(),
        config,
        EntityProfile::Update,
      );

      mod_block = mod_block
        .line_skip(1)
        .line(format!("#[derive({})]", marcros.join(", ")))
        .block(table_block);
    }

    acc.line_skip(1).block(mod_block)
  })
}

fn gen_model_module_with_profile(
  table: TableBlock,
  config: &config::Config,
  profile: EntityProfile,
) -> Block {
  let ast::table::TableBlock {
    cols: fields,
    indexes,
    ..
  } = table.clone();

  let table_block = match profile {
    EntityProfile::Normal => Block::new(2, Some(format!("pub struct {}", "Model"))),
    EntityProfile::Create => Block::new(2, Some(format!("pub struct {}", "CreateModel"))),
    EntityProfile::Update => Block::new(2, Some(format!("pub struct {}", "UpdateModel"))),
  };

  fields.iter().cloned().fold(table_block, |acc, field| {
    match profile {
      EntityProfile::Normal => (),
      EntityProfile::Create => {
        if field.settings.is_pk {
          match config.is_create_model_primary_key_included {
            None if field.settings.is_incremental => {
              return acc;
            }
            Some(false) => {
              return acc;
            }
            _ => (),
          }
        }
      }
      EntityProfile::Update => {
        if field.settings.is_pk && !config.is_update_model_primary_key_included {
          return acc;
        }
      }
    };

    let mut field_rust_type = field.r#type.to_rust_type();

    match profile {
      EntityProfile::Normal => {
        if field.settings.is_nullable {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      },
      EntityProfile::Create => {
        if field.settings.is_nullable || field.settings.default.is_some() {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      },
      EntityProfile::Update => {
        if !field.settings.is_pk {
          field_rust_type = format!("Option<{}>", field_rust_type);
        }
      }
    };

    match &config.struct_visibility {
      StructVisibility::Public => {
        acc
          .line(format!("pub {}: {},", field.name, field_rust_type))
      },
      StructVisibility::Private => {
        acc
          .line(format!("{}: {},", field.name, field_rust_type))
      }
    }
  })
}

fn gen_enum_modules(ast: &analyzer::SemanticSchemaBlock, codegen: Codegen, config: &Config) -> Codegen {  
  ast.enums.clone().into_iter().fold(codegen, |acc, r#enum| {
    let ast::enums::EnumBlock {
      ident: ast::enums::EnumIdent { name, schema },
      values,
    } = r#enum;

    let enum_block = Block::new(1, Some(format!("pub enum {}", name.to_pascal_case())));

    let enum_block = values.into_iter().enumerate().fold(enum_block, |acc, (i, value)| {
      let value_name = value.value;
      let value = match config.enum_type {
        EnumType::Integer => {
          format!("{} = {}", value_name.to_pascal_case(), i)
        },
        EnumType::String(_) => {
          format!("{}", value_name.to_pascal_case())
        }
      };

      acc
        .line(format!("{},", value))
    });

    let sqlx_macro = match &config.enum_type {
      EnumType::Integer => {
        format!("#[repr(i32)]")
      },
      EnumType::String(case) => {
        let case = case.as_ref().map(|case| {
          match case {
            EnumTypeCase::LowerCase => "lowercase",
            EnumTypeCase::SnakeCase => "snake_case",
            EnumTypeCase::UpperCase => "UPPERCASE",
            EnumTypeCase::ScreamingSnakeCase => "SCREAMING_SNAKE_CASE",
            EnumTypeCase::KebabCase => "kebab-case",
            EnumTypeCase::CamelCase => "camelCase",
            EnumTypeCase::PascalCase => "PascalCase",
          }
        });

        let mut attrs = vec![];

        attrs.push(format!(r#"type_name = "{}""#, name));

        if let Some(case) = case {
          attrs.push(format!(r#"rename_all = "{}""#, case));
        }

        format!(r#"#[sqlx({})]"#, attrs.join(", "))
      }
    };

    let marcros: Vec<_> = vec![format!("sqlx::Type")]
      .into_iter()
      .chain(config.enum_macros.clone())
      .collect();
    acc
      .line_skip(1)
      .line(format!("#[derive({})]", marcros.join(", ")))
      .line(format!("{}", sqlx_macro))
      .block(enum_block)
  })
}
